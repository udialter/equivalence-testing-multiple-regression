---
title: "Thesis Function"
author: "Udi Alter"
output:
  word_document: default
  html_document: default
---

```{r setup, include=FALSE}
library(haven)
library(psych)
library(car)
library(psychometric)
library(QuantPsyc)
library(lsr) 
library(apaTables)
library(dplyr)
library(broom)
```

```{r prequisites}

OCD <- read_sav("OCD and MW (Seli et al., 2017).sav") # Uploading data
ocd <- OCD # duplicating dataset for manipulation 
colnames(ocd) <- c("ID", "sample", "age","gender", "hand", "MWS", "MWD", 'BSCS', 'ocd_cont', 'ocd_resp', 'ocd_unacpthts', 'ocd_symm')

# OCD responsibility for harm and mistakes
resp<-lm(ocd_resp~MWD+MWS, data=ocd)
cont<-lm(ocd_cont~MWD+MWS, data=ocd)
summary(resp)
confint(resp)
lm.beta(resp) 

```

```{r regquivalence function}

reg.equiv <- function(datfra, model, predictor, delta, alpha=.05, plot=TRUE, test="TOST", std=TRUE) {
          
          # reg. coefficient point estimate and ci's
          modres <- summary(model)
          b.num <- grep(predictor, attr(model$terms , "term.labels"))+1 # this will indicate the place/number of the predictor in the model (e.g., 1st pred.) accounts for the intercept as well
          b <- model$coefficients[b.num] # extract raw coefficient value
          l.ci <- confint(model)[predictor,][1] # extract raw coefficient value, lower bound 95%
          u.ci <- confint(model)[predictor,][2] # extract raw coefficient value, upper bound 95%
          l.ci90 <- confint(model, level = .9)[predictor,][1] # extract raw coefficient value, lower bound 90%
          u.ci90 <- confint(model, level = .9)[predictor,][2] # extract raw coefficient value, upper bound 90%
          
          # std.error, degrees of freedom, and prerequisites
          err <- modres$coefficients[b.num,2] # extract standard error for predictor
          df <- model$df.residual # extract degrees of freedom for model
          depname <- attr(model$terms, "variables")[[2]] # extract name of outcome variable
          dep <- as.double(unlist(datfra[,depname])) # extract raw dependent variable values
          pred <- as.double(unlist(datfra[,predictor])) # extract raw (tested) predictor variable values
          
          #delta
          l.delta <- -abs(delta) # lower equivalence interval bound (consider to make it as input in the function)
          u.delta <- abs(delta) # upper equivalence interval bound
          
          # standardized forms (beta, variables, delta, ci's)
          beta <- data.frame(lm.beta(model))[predictor,] # extract standardized coefficient value
          beta.err <- err*beta/b
          dep.z <- (dep-mean(dep))/sd(dep) # constructing z scores for the dependent variable 
          pred.z <- (pred-mean(pred))/sd(pred) # constructing z scores for the predictor variable
          std.delta <- delta*sd(pred)/sd(dep) # constructing a standardized form of delta
          u.std.delta <- abs(std.delta) # standardized delta, upper
          l.std.delta <- -abs(std.delta) # standardized delta, lower
          l.std.ci <- (confint(model)[predictor,][1])*sd(pred)/sd(dep) # converting lower 95% ci to standardized form-------------Are the std CI conversion right?!
          u.std.ci <- (confint(model)[predictor,][2])*sd(pred)/sd(dep) # converting upper 95% ci to standardized form
          l.std.ci90 <- (confint(model, level = .9)[predictor,][1])*sd(pred)/sd(dep) # converting lower 90% ci to standardized form
          u.std.ci90 <- (confint(model, level = .9)[predictor,][2])*sd(pred)/sd(dep) # converting upper 90% ci to standardized form
  
          # RESULYS SECTION
              # standardized section
              if (std==TRUE) {
                              std.delta <- delta
                              u.std.delta <- abs(std.delta)
                              l.std.delta <- -abs(std.delta)
                              
                                 if (test=="AH") {     
                                                # AH
                                                t.std.ah <- beta/beta.err
                                                p.std.ah <- pt((abs(beta)-std.delta)/(sqrt(beta.err^2)),df) - pt((-abs(beta)-std.delta)/(sqrt(beta.err^2) ), df)
           
                                                cat("standardized regression coefficient for", predictor,":", "\n",
                                                "β = ",beta," , 95% CI [",l.std.ci,",",u.std.ci,"]" ,"\n", 
                                                "associated std. error = ", beta.err, "\n", "\n",
                                                "std. equivalence interval =","[",l.std.delta,",",u.std.delta,"]", "\n",
                                                "\n",
                                                "Anderson-Hauck (AH) Equivalence Test Results:", "\n",
                                                "-------------------------------------------------", "\n",
                                                "t(",df,") = ",t.std.ah,"\n",
                                                "p = ",p.std.ah,"\n",
                                                ifelse(p.std.ah < alpha, "AH: Negligible effects concluded" , 'AH: Insufficient evidence for negligible effects'))
                                    }  else { 
                                                # TOST
                                                t1.std.tost<- (beta-(-std.delta))/(sqrt(beta.err^2)) 
                                                t2.std.tost<- (std.delta-beta)/(sqrt(beta.err^2))
                                                p1.std.tost<- 1-pt(t1.std.tost, df) 
                                                p2.std.tost<- 1-pt(t2.std.tost, df)
                                                
                                                cat("standardized regression coefficient for", predictor,":", "\n",
                                                "β = ",beta," , 95% CI [",l.std.ci,",",u.std.ci,"]" ,"\n", 
                                                "associated std. error = ", beta.err, "\n", "\n",
                                                "std. equivalence interval =","[",l.std.delta,",",u.std.delta,"]", "\n",
                                                "\n",
                                                "Two One-Sided Test (TOST) Equivalence Test Results:", "\n",
                                                "-------------------------------------------------", "\n",
                                                "t1(",df,") = ",t1.std.tost,"\n",
                                                "t2(",df,") = ", t2.std.tost, "\n",
                                                "p1 = ",p1.std.tost,"\n",
                                                "p2 = ",p2.std.tost,"\n",
                                                ifelse(p1.std.tost < alpha & p2.std.tost < alpha, 'TOST: Negligible effects concluded', 'TOST: Insufficient evidence for negligible effects'))
                                              }
                                                # plot
                                  if (plot==TRUE) { 
                                                    plot(NA, axes=F,
                                                    xlim = c(min(l.std.ci,l.std.delta)-max(u.std.ci-l.std.ci, u.std.delta-l.std.delta)/10, max(u.std.ci,u.std.delta)+max(u.std.ci-l.std.ci, u.std.delta-l.std.delta)/10),
                                                    ylim = c(0,1),
                                                    yaxt='n',
                                                    ylab="",
                                                    xlab = "Std. Regression Coefficient Estimate", 
                                                    main = "Symmetric CI Approach \n 90% CI")
                                                    abline(v =0 , lty = 2, col= "light grey") # vertical line in the middle of the eq. interval, right now it's always 0, can be changed
                                                    points(x=beta, y=.5, pch=8, cex=2) # point at the estimated predictor value
                                                    abline(v=u.std.delta, lty=2, col = "red") # mark the upper eq. bound
                                                    abline(v=l.std.delta, lty=2, col = "red") # mark the lower eq. bound
                                                    segments(l.std.ci90,0.5,u.std.ci90,0.5, lwd=3) # plotting the 90% CI for the predictor estimate
                                                    text(u.std.delta*1.01,.5,"upper equivalence bound",srt=270,pos=3, offset = .5, col = "red") # text for eq. bound line (upper)
                                                    text(l.std.delta*1.01,.5,"lower equivalence bound",srt=90,pos=3, offset = .5, col = "red") # text for eq. bound line (lower)
                                                    text(u.std.delta*.9,-0.01,u.std.delta,srt=0,pos=3, offset = .5, col = "red") # writing the eq. interval bound value (upper)
                                                    text(l.std.delta*0.88,-.01,l.std.delta,srt=0,pos=3, offset = .5, col = "red") # writing the eq. interval bound value (lower)
                                                    text(beta,.57,round(beta, digits = 3),srt=0) # writing the predictor point estimate value
                                                    text(beta,.57,"β=",srt=0, pos = 2, offset = 1.5) # adding text to indicate above line
                                                    text(u.std.ci90,.45,round(u.std.ci90, digits = 3),pos =1, offset = .1, col = "black") # writing the 90% CI upper limit value for the predictor estimate
                                                    text(l.std.ci90,.45,round(l.std.ci90, digits = 3), pos =1, offset = .1,col = "black") # writing the 90% CI lower limit value for the predictor estimate
                                                    axis(side=1, pos=0, lwd.ticks=0)
                                                    }
              } else {
                      # unstandardized section  
                      if (test=="AH") {     
                      # AH
                      t.ah <- modres$coefficients[b.num,3]
                      p.ah <- pt((abs(b)-delta)/(sqrt(err^2)),df) - pt((-abs(b)-delta)/(sqrt(err^2) ), df)
    
                      cat("unstandardized regression coefficient for", predictor,":", "\n",
                      "b = ",b," , 95% CI [",l.ci,",",u.ci,"]" ,"\n", 
                      "std. error = ", err, "\n", "\n",
                      "standarized regression coefficient for", predictor,":","\n", 
                      "β = ", beta,", 95% CI [",l.std.ci,",",u.std.ci,"]", "\n", "\n",
             
                      "raw equivalence interval =","[",l.delta,",",u.delta,"]", "\n",
                      "std. equivalence interval =","[",l.std.delta,",",u.std.delta,"]", "\n",
                      "\n",
                      "Anderson-Hauck (AH) Equivalence Test Results:", "\n",
                      "-------------------------------------------------", "\n",
                      "t(",df,") = ",t.ah,"\n",
                      "p = ",p.ah,"\n",
                      ifelse(p.ah < alpha, "AH: Negligible effects concluded" , 'AH: Insufficient evidence for negligible effects'))
                   }  else { 
                      # TOST
                      t1.tost<- (b-(-delta))/(sqrt(err^2)) 
                      t2.tost<- (delta-b)/(sqrt(err^2))
                      p1.tost<- 1-pt(t1.tost, df) 
                      p2.tost<- 1-pt(t2.tost, df)
      
                     cat("unstandardized regression coefficient for", predictor,":", "\n",
                     "b = ",b," , 95% CI [",l.ci,",",u.ci,"]" ,"\n", 
                     "std. error = ", err, "\n", "\n",
                     "standarized regression coefficient for", predictor,":","\n", 
                     "β = ", beta,", 95% CI [",l.std.ci,",",u.std.ci,"]", "\n", "\n",
             
                     "raw equivalence interval =","[",l.delta,",",u.delta,"]", "\n",
                     "std. equivalence interval =","[",l.std.delta,",",u.std.delta,"]", "\n",
                     "\n",
                     "Two One-Sided Test (TOST) Equivalence Test Results:", "\n",
                     "-------------------------------------------------", "\n",
                     "t1(",df,") = ",t1.tost,"\n",
                     "t2(",df,") = ", t2.tost, "\n",
                     "p1 = ",p1.tost,"\n",
                     "p2 = ",p2.tost,"\n",
                     ifelse(p1.tost < alpha & p2.tost < alpha, 'TOST: Negligible effects concluded', 'TOST: Insufficient evidence for negligible effects'))
                    }
                      # plot
                      if (plot==TRUE) { 
                      plot(NA, axes=F,
                      xlim = c(min(l.ci,l.delta)-max(u.ci-l.ci, u.delta-l.delta)/10, max(u.ci,u.delta)+max(u.ci-l.ci, u.delta-l.delta)/10),
                      ylim = c(0,1),
                      yaxt='n',
                      ylab="",
                      xlab = "Regression Coefficient Estimate", 
                      main = "Symmetric CI Approach \n 90% CI")
                      abline(v =0 , lty = 2, col= "light grey") # vertical line in the middle of the eq. interval, right now it's always 0, can be changed
                      points(x=b, y=.5, pch=8, cex=2) # point at the estimated predictor value
                      abline(v=u.delta, lty=2, col = "red") # mark the upper eq. bound
                      abline(v=l.delta, lty=2, col = "red") # mark the lower eq. bound
                      segments(l.ci90,0.5,u.ci90,0.5, lwd=3) # plotting the 90% CI for the predictor estimate
                      text(u.delta*1.01,.5,"upper equivalence bound",srt=270,pos=3, offset = .5, col = "red") # text for eq. bound line (upper)
                      text(l.delta*1.01,.5,"lower equivalence bound",srt=90,pos=3, offset = .5, col = "red") # text for eq. bound line (lower)
                      text(u.delta*.9,-0.01,u.delta,srt=0,pos=3, offset = .5, col = "red") # writing the eq. interval bound value (upper)
                      text(l.delta*0.88,-.01,l.delta,srt=0,pos=3, offset = .5, col = "red") # writing the eq. interval bound value (lower)
                      text(b,.57,round(b, digits = 3),srt=0) # writing the predictor point estimate value
                      text(b,.57,"b=",srt=0, pos = 2, offset = 1.5) # adding text to indicate above line
                      text(u.ci90,.45,round(u.ci90, digits = 3),pos =1, offset = .1, col = "black") # writing the 90% CI upper limit value for the predictor estimate
                      text(l.ci90,.45,round(l.ci90, digits = 3), pos =1, offset = .1,col = "black") # writing the 90% CI lower limit value for the predictor estimate
                      axis(side=1, pos=0, lwd.ticks=0)
                                  }
                                }     
                              } # end of function








#testing the function

reg.equiv(ocd,cont,"MWD",.13, test = "AH")  
reg.equiv(ocd,cont,"MWD",.13)

reg.equiv(ocd,cont,"MWD",0.23, std=F)

```
